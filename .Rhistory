})
}
if (is.null(commune_sf) || nrow(commune_sf) == 0) {
print("Aucune donn√©e de commune disponible")
return(NULL)
}
# Cr√©er un point √† partir des coordonn√©es (en WGS84)
point <- sf::st_sfc(sf::st_point(c(lon, lat)), crs = 4326)
# Trouver la commune qui contient le point
print("Recherche de la commune contenant le point...")
commune_found <- NULL
tryCatch({
# Utiliser st_intersects pour trouver quelle commune contient le point
intersects <- sf::st_intersects(point, commune_sf)
if (length(intersects[[1]]) > 0) {
# R√©cup√©rer la premi√®re commune qui contient le point
commune_idx <- intersects[[1]][1]
commune_found <- commune_sf[commune_idx, ]
# Extraire les informations de la commune
code_commune <- as.character(commune_found$CODE_C)
commune_name <- as.character(commune_found$LIB)
print(paste("Commune trouv√©e par intersection spatiale:", commune_name, "Code:", code_commune))
return(list(
code = code_commune,
name = commune_name
))
} else {
print("Aucune commune ne contient ce point. Recherche de la commune la plus proche...")
# Comme alternative, trouver la commune la plus proche
dists <- sf::st_distance(point, commune_sf)
nearest_idx <- which.min(dists)
nearest_commune <- commune_sf[nearest_idx, ]
nearest_code <- as.character(nearest_commune$CODE_C)
nearest_name <- as.character(nearest_commune$LIB)
# Calculer la distance en m√®tres
min_dist <- min(dists)
print(paste("Commune la plus proche:", nearest_name, "Code:", nearest_code,
"Distance:", round(min_dist), "m√®tres"))
# Ne retourner la commune la plus proche que si elle est √† moins de 5km
if (min_dist < 5000) {
return(list(
code = nearest_code,
name = nearest_name,
approx = TRUE,
distance = round(min_dist)
))
} else {
print("La commune la plus proche est trop √©loign√©e (>5km)")
return(NULL)
}
}
}, error = function(e) {
print(paste("Erreur lors de la recherche spatiale:", e$message))
return(NULL)
})
return(NULL)
}
# Observer pour la s√©lection d'un r√©sultat de recherche
observeEvent(input$selectedAddress, {
# Extraire les coordonn√©es de l'adresse s√©lectionn√©e
index <- as.numeric(input$selectedAddress)
addresses <- search_results()
if (!is.null(addresses) && index <= length(addresses)) {
selected <- addresses[[index]]
# V√©rifier que l'adresse s√©lectionn√©e est une liste valide
if (!is.list(selected)) {
print("Erreur: L'adresse s√©lectionn√©e n'est pas une liste valide")
return()
}
# Stocker l'adresse s√©lectionn√©e pour le diagnostic
selected_address_for_diag(if ("label" %in% names(selected)) selected$label else "Adresse sans nom")
# V√©rifier que longitude et latitude existent
if (!"longitude" %in% names(selected) || !"latitude" %in% names(selected) ||
is.null(selected$longitude) || is.null(selected$latitude) ||
is.na(selected$longitude) || is.na(selected$latitude)) {
print("Coordonn√©es manquantes dans les r√©sultats de recherche")
return()
}
# Zoomer sur l'adresse s√©lectionn√©e
leafletProxy("map") %>%
setView(lng = selected$longitude, lat = selected$latitude, zoom = 14) %>%
# Nettoyer les anciens marqueurs et ajouter un nouveau marqueur
clearGroup("searchMarkers") %>%
addMarkers(
lng = selected$longitude,
lat = selected$latitude,
popup = if ("label" %in% names(selected)) selected$label else "Adresse s√©lectionn√©e",
group = "searchMarkers"
)
# D√©tection de commune par analyse spatiale avec les fichiers GPKG
commune_found <- FALSE
print(paste("Coordonn√©es valides, d√©tection de la commune...", selected$longitude, selected$latitude))
# Utiliser notre nouvelle fonction pour d√©tecter la commune
commune_info <- find_commune_by_gps(selected$longitude, selected$latitude)
if (!is.null(commune_info) && is.list(commune_info)) {
# La commune a √©t√© trouv√©e, on stocke ses informations
if ("code" %in% names(commune_info) && "name" %in% names(commune_info)) {
code_commune <- commune_info$code
commune_name <- commune_info$name
# V√©rification suppl√©mentaire pour s'assurer que les valeurs ne sont pas NULL ou NA
if (!is.null(code_commune) && !is.na(code_commune) &&
!is.null(commune_name) && !is.na(commune_name)) {
# V√©rifier si la commune a √©t√© trouv√©e par approximation
if ("approx" %in% names(commune_info) && isTRUE(commune_info$approx) &&
"distance" %in% names(commune_info)) {
print(paste("Commune approximative trouv√©e par proximit√©:", commune_name,
"Code:", code_commune, "Distance:", commune_info$distance, "m"))
msg <- paste("Commune d√©tect√©e (approximative, √†", commune_info$distance, "m):",
commune_name, "(", code_commune, ")")
} else {
print(paste("Commune trouv√©e par analyse spatiale:", commune_name, "Code:", code_commune))
msg <- paste("Commune d√©tect√©e:", commune_name, "(", code_commune, ")")
}
selected_commune_code(code_commune)
selected_commune_name(commune_name)
commune_found <- TRUE
# Notification pour l'utilisateur
showNotification(msg, type = "message", duration = 5)
# Indiquer √† l'utilisateur qu'il peut g√©n√©rer un diagnostic
output$diagInstructions <- renderUI({
div(
style = "margin-top: 10px; padding: 10px; background-color: #dff0d8; border-radius: 5px;",
p(icon("info-circle"), " Commune identifi√©e avec succ√®s. Vous pouvez maintenant t√©l√©charger le diagnostic climatique.")
)
})
} else {
print("R√©sultat de commune valide mais code ou nom manquant")
}
} else {
print("Structure de commune_info incorrecte: code ou name manquant")
}
} else {
print("Aucune commune n'a √©t√© d√©tect√©e via l'analyse spatiale")
}
# Si la commune n'est pas trouv√©e par l'analyse spatiale, proposer l'entr√©e manuelle
if (!commune_found) {
output$diagInstructions <- renderUI({
div(
style = "margin-top: 10px; padding: 10px; background-color: #fcf8e3; border-radius: 5px;",
p(icon("exclamation-triangle"), " Impossible de d√©tecter automatiquement la commune pour cette adresse."),
p("Vous pouvez entrer manuellement le code INSEE et le nom de la commune :"),
div(
style = "display: flex; gap: 10px; margin-top: 10px;",
textInput("manualCommuneCode", "Code INSEE", width = "150px"),
textInput("manualCommuneName", "Nom de la commune", width = "250px"),
actionButton("setManualCommune", "D√©finir la commune", class = "btn-primary")
)
)
})
}
}
})
# Observer pour la d√©finition manuelle d'une commune
observeEvent(input$setManualCommune, {
code_commune <- input$manualCommuneCode
commune_name <- input$manualCommuneName
# V√©rifier que les champs ne sont pas vides
if (nchar(code_commune) > 0 && nchar(commune_name) > 0) {
selected_commune_code(code_commune)
selected_commune_name(commune_name)
showNotification(
paste("Commune d√©finie manuellement:", commune_name, "(", code_commune, ")"),
type = "message",
duration = 5
)
output$diagInstructions <- renderUI({
div(
style = "margin-top: 10px; padding: 10px; background-color: #dff0d8; border-radius: 5px;",
p(icon("info-circle"), " Commune d√©finie avec succ√®s. Vous pouvez maintenant t√©l√©charger le diagnostic climatique.")
)
})
} else {
showNotification(
"Veuillez remplir √† la fois le code INSEE et le nom de la commune.",
type = "error",
duration = 5
)
}
})
# Afficher la commune s√©lectionn√©e dans l'onglet diagnostic
output$diagSelectedCommune <- renderText({
code <- selected_commune_code()
name <- selected_commune_name()
if (is.null(code) || is.null(name)) {
"Aucune commune s√©lectionn√©e."
} else {
paste("Commune : ", name, " (Code : ", code, ")")
}
})
# Observer pour le bouton de diagnostic - redirection vers l'onglet diagnostic
observeEvent(input$goDiagnostic, {
updateNavbarPage(session, "navbarPage", selected = "Diagnostic ü©∫")
})
# Afficher l'adresse s√©lectionn√©e dans l'onglet diagnostic
output$diagSelectedAddress <- renderText({
addr <- selected_address_for_diag()
if (is.null(addr)) {
"Aucune adresse s√©lectionn√©e. Utilisez la recherche d'adresse dans l'onglet 'Carte interactive'."
} else {
addr
}
})
# Handler pour le t√©l√©chargement du diagnostic en PDF
output$downloadDiagnostic <- downloadHandler(
filename = function() {
# Nom de fichier personnalis√© avec la commune et la date
commune_name <- selected_commune_name()
if (is.null(commune_name)) {
commune_name <- "inconnue"
} else {
# Nettoyer le nom pour qu'il soit utilisable dans un nom de fichier
commune_name <- gsub("[^a-zA-Z0-9]", "_", commune_name)
}
paste0("Diagnostic_climatique_", commune_name, "_", format(Sys.Date(), "%Y%m%d"), ".pdf")
},
content = function(file) {
# V√©rifier si on a une commune s√©lectionn√©e
code_commune <- selected_commune_code()
commune_name <- selected_commune_name()
if (is.null(code_commune) || is.null(commune_name)) {
# Si aucune commune n'est s√©lectionn√©e, afficher un message d'erreur
showNotification("Aucune commune s√©lectionn√©e pour le diagnostic.", type = "error", duration = 5)
return()
}
# Afficher un message de chargement
withProgress(message = 'G√©n√©ration du diagnostic en cours...', value = 0.3, {
# Effacer le cache pour s'assurer que de nouvelles donn√©es sont g√©n√©r√©es
if (exists("excel_data_cache", envir = .GlobalEnv)) {
rm("excel_data_cache", envir = .GlobalEnv)
}
# Tenter de g√©n√©rer le PDF
success <- tryCatch({
# Mise √† jour de la barre de progression
incProgress(0.3, detail = "Cr√©ation des graphiques...")
# G√©n√©rer le PDF de diagnostic
generate_diagnostic_pdf(file, code_commune, commune_name)
# Mise √† jour de la barre de progression
incProgress(0.4, detail = "Finalisation...")
TRUE  # Succ√®s
}, error = function(e) {
# En cas d'erreur, afficher un message et retourner FALSE
print(paste("Erreur lors de la g√©n√©ration du PDF:", e$message))
showNotification(paste("Erreur:", e$message), type = "error", duration = 10)
FALSE
})
if (success) {
showNotification(paste("Diagnostic pour", commune_name, "g√©n√©r√© avec succ√®s!"),
type = "message", duration = 5)
}
})
}
)
# Fonction pour charger et mettre en cache les fichiers Excel
load_excel_files <- function() {
# On ne v√©rifie plus le cache global pour forcer de nouvelles donn√©es √† chaque appel
# if (exists("excel_data_cache", envir = .GlobalEnv)) {
#   print("Utilisation des donn√©es Excel en cache global")
#   return(get("excel_data_cache", envir = .GlobalEnv))
# }
print("Chargement des fichiers Excel...")
# RECHERCHE DE FICHIERS EXCEL DANS DIFF√âRENTS R√âPERTOIRES
possible_paths <- c(
"Data/INDICATEURS_SAISONNIERS_ETE",
"Data/INDICATEURS_ANNUELS_HORIZONS",
"Data",
"."
)
excel_files <- c(
"DRIAS_ETE_REFERENCE_clean_FINAL_RESULTS_COMMUNES.xlsx",
"DRIAS_ETE_2_6_clean_FINAL_RESULTS_COMMUNES.xlsx",
"DRIAS_ETE_4_5_clean_FINAL_RESULTS_COMMUNES.xlsx",
"DRIAS_ETE_8_5_clean_FINAL_RESULTS_COMMUNES.xlsx"
)
# V√©rifier si des fichiers existent
found_files <- list()
for (path in possible_paths) {
for (file in excel_files) {
file_path <- file.path(path, file)
if (file.exists(file_path)) {
found_files[[file]] <- file_path
print(paste("Fichier trouv√©:", file_path))
}
}
}
# V√©rifier si nous avons trouv√© les fichiers
if (length(found_files) < length(excel_files)) {
print("ATTENTION: Certains fichiers Excel n'ont pas √©t√© trouv√©s!")
print("G√©n√©ration de donn√©es fictives pour le diagnostic...")
# G√©n√©rer des donn√©es simul√©es bas√©es sur environ 35000 communes
generate_mock_data <- function(n_communes = 100) {
# Cr√©ation d'un ensemble de CODE_C simul√©s (codes INSEE)
# On n'utilise plus de seed fixe pour assurer des donn√©es diff√©rentes √† chaque appel
# set.seed(123)  # Pour la reproductibilit√©
# Cr√©er 100 communes al√©atoires (au lieu de 35000 pour des raisons de performance)
code_c <- sprintf("%05d", sample(1:99999, n_communes))
# Cr√©er des noms de communes fictifs
commune_names <- sapply(1:n_communes, function(i) paste("Commune", i))
# G√©n√©rer quelques codes postaux
cp <- sprintf("%05d", sample(10000:99999, n_communes, replace=TRUE))
# Cr√©er un dataframe de base
base_df <- data.frame(
CODE_C = code_c,
LIB = commune_names,
CP = cp,
stringsAsFactors = FALSE
)
# Ajouter des variables climatiques pour diff√©rents horizons
add_climate_vars <- function(base_df, prefix) {
df <- base_df
# R√©f√©rence
df[[paste0(prefix, "_REF")]] <- runif(n_communes, 10, 30)
# Horizons H1, H2, H3
for (h in c("H1", "H2", "H3")) {
df[[paste0(prefix, "_", h)]] <-
df[[paste0(prefix, "_REF")]] + runif(n_communes, 0.5, 5) *
match(h, c("H1", "H2", "H3"))  # Augmentation progressive avec l'horizon
}
return(df)
}
# Ajouter toutes les variables climatiques n√©cessaires
for (prefix in c("NORTAV", "NORSD", "NORTX35")) {
base_df <- add_climate_vars(base_df, prefix)
}
return(base_df)
}
# G√©n√©rer les donn√©es de r√©f√©rence
mock_data <- generate_mock_data()
# Ajouter la ligne pour notre code_commune sp√©cifique
code_commune_specific <- selected_commune_code()
commune_name_specific <- selected_commune_name()
if (!is.null(code_commune_specific) && !is.null(commune_name_specific)) {
specific_row <- mock_data[1,]
specific_row$CODE_C <- code_commune_specific
specific_row$LIB <- commune_name_specific
mock_data <- rbind(mock_data, specific_row)
}
# Cr√©er des donn√©es l√©g√®rement diff√©rentes pour chaque sc√©nario
modify_for_scenario <- function(base_df, intensity = 1) {
df <- base_df
# Ajuster les valeurs pour diff√©rents sc√©narios
for (prefix in c("NORTAV", "NORSD", "NORTX35")) {
for (h in c("H1", "H2", "H3")) {
col <- paste0(prefix, "_", h)
if (col %in% names(df)) {
df[[col]] <- df[[col]] * (1 + intensity * 0.1 * match(h, c("H1", "H2", "H3")))
}
}
}
return(df)
}
mock_ref <- mock_data
mock_s26 <- modify_for_scenario(mock_data, 0.5)  # Intensit√© plus faible
mock_s45 <- modify_for_scenario(mock_data, 1)    # Intensit√© moyenne
mock_s85 <- modify_for_scenario(mock_data, 1.5)  # Intensit√© forte
# Stocker les donn√©es simul√©es
excel_data <- list(
ref = mock_ref,
s26 = mock_s26,
s45 = mock_s45,
s85 = mock_s85
)
print("Donn√©es simul√©es g√©n√©r√©es avec succ√®s!")
print(paste("Communes simul√©es:", nrow(mock_ref)))
print(paste("Variables incluses:", paste(names(mock_ref)[-(1:3)], collapse=", ")))
# Ne plus mettre en cache global
# assign("excel_data_cache", excel_data, envir = .GlobalEnv)
return(excel_data)
}
# Si tous les fichiers sont trouv√©s, les charger normalement
print("Tous les fichiers Excel ont √©t√© trouv√©s. Chargement...")
tryCatch({
# Charger les fichiers Excel dans l'ordre
ref_data <- readxl::read_excel(found_files[["DRIAS_ETE_REFERENCE_clean_FINAL_RESULTS_COMMUNES.xlsx"]])
s26_data <- readxl::read_excel(found_files[["DRIAS_ETE_2_6_clean_FINAL_RESULTS_COMMUNES.xlsx"]])
s45_data <- readxl::read_excel(found_files[["DRIAS_ETE_4_5_clean_FINAL_RESULTS_COMMUNES.xlsx"]])
s85_data <- readxl::read_excel(found_files[["DRIAS_ETE_8_5_clean_FINAL_RESULTS_COMMUNES.xlsx"]])
# Stocker les donn√©es
excel_data <- list(
ref = ref_data,
s26 = s26_data,
s45 = s45_data,
s85 = s85_data
)
print("Fichiers Excel charg√©s avec succ√®s!")
print(paste("Nombre de communes:", nrow(ref_data)))
# V√©rifier la pr√©sence de CODE_C
if ("CODE_C" %in% colnames(ref_data)) {
print(paste("Nombre de CODE_C uniques:", length(unique(ref_data$CODE_C))))
} else {
print("ATTENTION: La colonne CODE_C est absente!")
}
# Ne plus mettre en cache global
# assign("excel_data_cache", excel_data, envir = .GlobalEnv)
return(excel_data)
}, error = function(e) {
print(paste("Erreur lors du chargement des fichiers Excel:", e$message))
# G√©n√©rer des donn√©es fictives en cas d'erreur
print("G√©n√©ration de donn√©es fictives suite √† une erreur...")
generate_mock_data <- function(n_communes = 100) {
# Ne plus utiliser la m√™me graine √† chaque fois
# set.seed(123)
code_c <- sprintf("%05d", sample(1:99999, n_communes))
commune_names <- sapply(1:n_communes, function(i) paste("Commune", i))
cp <- sprintf("%05d", sample(10000:99999, n_communes, replace=TRUE))
base_df <- data.frame(
CODE_C = code_c,
LIB = commune_names,
CP = cp,
stringsAsFactors = FALSE
)
# Ajouter la commune demand√©e
code_commune_specific <- selected_commune_code()
commune_name_specific <- selected_commune_name()
if (!is.null(code_commune_specific) && !is.null(commune_name_specific)) {
new_row <- data.frame(
CODE_C = code_commune_specific,
LIB = commune_name_specific,
CP = substr(code_commune_specific, 1, 2) * 1000 + sample(100:999, 1),
stringsAsFactors = FALSE
)
base_df <- rbind(base_df, new_row)
}
# Ajouter des variables climatiques
for (prefix in c("NORTAV", "NORSD", "NORTX35")) {
base_df[[paste0(prefix, "_REF")]] <- runif(nrow(base_df), 10, 30)
for (h in c("H1", "H2", "H3")) {
base_df[[paste0(prefix, "_", h)]] <-
base_df[[paste0(prefix, "_REF")]] + runif(nrow(base_df), 0.5, 5) *
match(h, c("H1", "H2", "H3"))
}
}
return(base_df)
}
mock_data <- generate_mock_data()
excel_data <- list(
ref = mock_data,
s26 = mock_data,
s45 = mock_data,
s85 = mock_data
)
# Mettre en cache global
assign("excel_data_cache", excel_data, envir = .GlobalEnv)
return(excel_data)
})
}
# Observer pour le bouton de recherche d'adresse
observeEvent(input$searchBtnClicked, {
query <- input$searchBtnClicked$address
if (is.null(query) || nchar(query) < 3) {
# Afficher un message si la requ√™te est trop courte
session$sendCustomMessage(type = "updateSearchResults",
message = "<div style='color: #d9534f;'>Veuillez entrer au moins 3 caract√®res</div>")
return()
}
# Afficher un message de chargement
session$sendCustomMessage(type = "updateSearchResults",
message = "<div style='color: #5bc0de;'>Recherche en cours...</div>")
# Rechercher l'adresse avec l'API BAN
print(paste("Recherche de l'adresse:", query))
addresses <- tryCatch({
search_address(query)
}, error = function(e) {
print(paste("Erreur lors de la recherche BAN:", e$message))
list()
})
# Si aucun r√©sultat avec BAN, essayer avec Nominatim
if (length(addresses) == 0) {
print("Aucun r√©sultat avec BAN, tentative avec Nominatim")
addresses <- tryCatch({
search_address_nominatim(query)
}, error = function(e) {
print(paste("Erreur lors de la recherche Nominatim:", e$message))
list()
})
}
print(paste("Nombre de r√©sultats:", length(addresses)))
if (length(addresses) == 0) {
# Aucun r√©sultat trouv√©
session$sendCustomMessage(type = "updateSearchResults",
message = "<div style='color: #d9534f;'>Aucun r√©sultat trouv√©</div>")
} else {
# Construire la liste des r√©sultats
result_html <- "<div style='display: flex; flex-direction: column; gap: 5px;'>"
for (i in seq_along(addresses)) {
addr <- addresses[[i]]
# S'assurer que les donn√©es sont bien d√©finies
label <- ifelse(is.null(addr$label), "Adresse sans nom", addr$label)
type <- ifelse(is.null(addr$type), "inconnu", addr$type)
score <- ifelse(is.null(addr$score), 0, addr$score)
print(paste("R√©sultat", i, ":", label, "- Lat:", addr$latitude, "Lng:", addr$longitude))
result_html <- paste0(
result_html,
"<div class='address-result' style='padding: 5px; border-radius: 3px; cursor: pointer; background-color: #f5f5f5; border: 1px solid #ddd;' ",
"data-lat='", addr$latitude, "' data-lng='", addr$longitude, "'>",
"<div style='font-weight: bold;'>", label, "</div>",
"<div style='font-size: 0.8em; color: #666;'>Type: ", type, " | Score: ", round(score * 100), "%</div>",
"</div>"
)
}
result_html <- paste0(result_html, "</div>")
# Envoyer les r√©sultats au navigateur
session$sendCustomMessage(type = "updateSearchResults", message = result_html)
# Stocker les adresses dans la valeur r√©active au lieu de userData
search_results(addresses)
}
})
}
# Lancer l'application
shinyApp(ui = ui, server = server)
deployApp()
deployApp()
deployApp()
